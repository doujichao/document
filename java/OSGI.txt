OSGI(Open Service Gateway Initiative)

Bundle
-----------------------
	从形式上将就是在WEB-INF目录下的MANIFEST.MF文件中加入OSGI特定描述的jar包
	Bundle的生命周期被OSGI框架所管理，具有以下几个状态：
	INSTALLED(安装):
	RESOLVED(解决)：
	UNINSTALLED(卸载)：
	STARTING(开始)：
	ACTIVE(活动)：
	STOPPING(停止)：
	
	在OSGI中，每个Bundle都有自己独立于其他Bundle的ClassLoader。
	一个Bundle可能会用到另外的Bundle的类，Bundle之间的交互如何实现？
		1、通过package的export和import来进行
		2、通过service的方式来进行，而提供Service有两种方式：
			1、通过BundleContext来获取
			2、使用DeclarativeService来实现
Component 
-------------------------------------
	任何一个普通的java对象都可以通过配置文件中的定义变成一个Component，每个Bundle都含有多个Component
	
Declarative Service
------------------------
	通过DS，我们可以在Bundle中定义Component，通过配置的方式发布服务，获取服务

Service-Oriented Component Model(SOCM):	面向服务的组件模型，Component是服务的载体
	提供对外使用的服务并可能使用外部的服务
	
	
一些实例
Equinox
----------------------------
	是Eclipse中的项目

模块：一个从逻辑上封装实现类的集合，一个基于实现类子集的可选公共API，以及一个对外部
	代码依赖关系的集合
内聚：用于衡量一个模块的类相互关联的程度，以及共同完成模块既定功能的紧密程度
耦合：与内聚相反，是指不同模块束缚或依赖于其他模块的程度，应该尽量降低模块间的耦合度
	

模块化
------------------------------
	在计算机科学中，软件应用的代码可以被分割为表示独立内容的逻辑单元

创建osgi应用程序的通用方法
---------------------------------------
	1、设计应用，将它分解为一些服务接口和这些接口的客户端
	2、使用你选定的工具和方法来实现服务提供者和客户端组件
	3、将服务提供者和客户端组件打包成独立的jar文件，然后用合适的osgi元数据扩展每个jar文件
	4、启动osgi框架
	5、安装和启动所有来自步骤3的jar文件

OSGI架构
------------------------
	OSGI服务由两个部分组成：OSGI框架和OSGI标准服务
	OSGI框架：实现并提供OSGI功能的运行环境，这个框架依据OSGI规范中定义的三个概念层设计的
		模块层--------关注于打包和共享代码
			定义了OSGI模块的概念，并称之为一个bundle
		生命周期层----关注于提供执行代码时模块管理和对底层OSGI框架的访问
			定义了在OSGI框架中是如何动态安装和管理的，生命周期存在有两个目的，一个是，在应用
				程序的外部，生命周期层精确地定义了bundle生命周期的操作，这些生命周期操作使得
				你可以用一种定义明确的方式动态的提供、管理和改进你的应用程序，另一方面，在应
				用程序的内部，生命周期定义了bundle如何访问他们的执行环境，执行环境为bundle提
				供了一种与osgi框架交互的方式和执行是的一些便利。
		服务层--------关注于模块，特别是模块内的组件间的交互和通讯
	OSGI标准服务：定义了很多用于执行常见任务的可重用API
	
使用OSGI
--------------------------
	1、新建OSGI启动项目，Eclipse中Run Configurations
	2、取消勾选所有的Handles
	3、选择
		org.apache.felix.gogo.command
		org.apache.felix.gogo.runtime
		org.apache.felix.gogo.shell
		org.eclipse.equinox.console
		org.eclipse.osgi
		点击运行，控制台初选osgi> 为正常运行
	4、创建一个plign-in工程	，注意 an OSGI framework:选项选择standard
	5、输入Bundle的相关元数据信息
		Plug-in ID指的是唯一表示，在实际项目中可以采用类似java的包名组织的策略来保证标识的唯一性
		Plug-in Version指的是Bundle的版本
		Plug-in Name指的是Bundle的更具有意义的名称
		Plug-in Provider(Vendor)指的是Bundle的提供商
		Execution environment指的是Bundle运行需要的环境
		剩下的最关键的就是Activator部分了，这里填入自己的一个类名就可以了
	