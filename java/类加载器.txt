类加载
----------------------------
	虚拟机设计团队把类加载阶段中的‘通过一个类的全限定名来获取描述此类的二进制字节流’这个动作放到java虚拟机外部
	实现，以便让应用程序自己决定如何获取所需要的类，实现这个动作的代码模块被称为‘类加载器’
	
	比较两个类是否相等只有在同一个类加载器的前提下才有意义，否则即使这两个类是来源于同一个
	Class文件，只要加载他们的类加载器不同，那么这两个类就必定不相同
	这里的相等，包括代表类的Class对象的equals方法，isAssignableFrom方法，isInstance方法的返回接口，也包括了instanceof
	关键字做对象所属关系判断等情况
	
	
	对于虚拟机来说，只有两种类加载器：
		1、启动类加载器 BootStrap ClassLoader
			使用C++语言实现
		2、其他类加载器，这些类加载器又Java语言实现
			全部继承抽象类java.lang.ClassLoader
		
	对于Java开发人员来说，类加载器可以划分为更细致一些
		1、启动类加载器 
			可以通过-Xbootclasspath指定路径
		2、扩展类加载器
			这个类加载器由sun.misc.Launcher$ExtClassLoader实现，负责加载<JAVA_HOME>\lib\ext
			目录中的，或者被java.ext.dirs系统属性所指定的路径中的所有类库
		3、应用程序类加载器
			可以通过sun.misc.Launcher$AppClassLoader来实现，由于这个类加载器是ClassLader中的
			getSystemClassLoader方法的返回值，所以一般也称它为系统类加载器，它负责加载用户类路径
			上所指定的类库，开发者可以直接使用这个类加载器，
			
类加载器的双亲委派模型
	模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器，这里的类加载器之间
	的父子关系一般不会以继承的关系来实现，而都是使用组合关系来服用父加载器的代码
	
	组合：把旧类对象作为新对象的成员对象组合起来，用于实现新类的功能，用户看到的是新类的发方法
		而不能看到被组合的对象，因此，通常使用private修饰被组合的旧类对象
		
	工作流程：
		如果一个类加载器收到了类加载的请求，首先不会自己去尝试加载这个类，而是把这个类委派给父类
		加载器去完成，每一个层次的类加载器都是如此，因此所有的类加载请求最终都因该传送到顶层
		的启动类加载器中，只有当类加载反馈自己无法完成这个加载请求(搜索范围没有)时，子加载器才会去尝试加载
		
	实现：
		实现双亲委派的代码都集中在java.lang.ClassLoader的loaderClass()方法中
		1、检查类是否已经被加载过了
		2、调用父类加载类
		3、调用自身加载类
		
	OSGI热加载搜索流程：
		1、将以java.*开头的类，委托给父类加载器加载
		2、否则，将委托列表名单内的类，委派给父类加载器加载
		3、否则，将Import列表的类，委派给Export这个类的Bundle的类加载器加载
		4、否则，查找Bundle的ClassPath，使用自己的类加载器加载
		5、否则，查找类是否在自己的Fragment Bundle中，如果在委派给Fragment Bundle的类加载器加载
		6、否则，查找Dynamic Import列表中的Bundle，委派给对应的Bundle的类加载器加载
		7、否则，不加载