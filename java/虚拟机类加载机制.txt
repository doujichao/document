虚拟机类加载机制
-------------------------
	虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换、解析
	最终形成虚拟机可以直接使用的Java类型，这就是虚拟机的类加载机制
	
两个约定
---------------------------
	1、每个Class文件都有可能代表着Java语言中的一个类或者接口
		类和接口需要分开描述的场景会特别说明
	2、这里所说的‘Class文件’并非指存在与具体磁盘中的某个文件
		这里所属的class文件指的是一串二进制字节流，无论以何种
		形式存在都可以
		
类加载时机
------------------------------------
	类加载的生命周期：
		加载(Loading)
		
		验证(Verification)
		准备(Preparation)
		解析(Resolution)
		
		初始化(Initialization)
			调用：
				1、当遇到new 、getstatic 、putstatic 、invokestatic四条指令时，如果类没有进行初始化
				则需要首先触发其初始化
				2、使用java.lang.reflect包的方法对类进行反射调用，如果没有进行初始化，则出发初始化
				3、当初始化一个类的时候，发现父类没有进行初始化，则先出发父类初始化
				4、当虚拟机启动的时候，用户需要指定也给要执行的主类，虚拟机会初始化这个类
				注意：以上四种行为被称为主动引用，除此之外所有引用类的方式，都不会触发初始化，被称为被动引用
				不会触发的几种情况：
					1、通过子类调用父类的静态变量，不会触发子类的初始化
					2、通过数组定义来引用类，不会触发此类的初始化，这里由虚拟机自动生成
						一个Object的子类来触发
					3、调用常量不会进行初始化，常量在编译的时候会被存入常量池，因此不会触发类的初始化
			场景：1、new关键字实例化对象(new)
				  2、读取或设置一个类的静态字段(getstatic,putstatic)
				  3、调用一个类的静态方法(invokestatic)
		使用(Using)
		卸载(Unloading)
		
	其中，验证、准备、解析这三个阶段统称为连接(Linking)，
	注意：加载、验证、准备、初始化、和卸载这几个过程的顺序是确定的
		而解析的过程则不一定
		
类加载过程
---------------------------
	1、加载
		1、通过一个类的全限定名来获取定义此类的二进制字节流
			类加载的来源：
			1、这里不一定都是从Class文件中读取，还可以从zip，jar，ear，war包中读取
			2、从网络中读取，这种场景最经典的应用就是applet
			3、运行时计算生成，这种场景使用最多的就是动态代理技术，在java.lang.reflect.Proxy
			4、由其他文件生成
			5、从数据库读取，这种场景相对少见，有些中间件服务器可以选择把程序安装到
				数据库中来完成代码在集群间的分发
		2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
		3、在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口
	2、验证
		验证是连接的第一步，这一步阶段的目的是为了确保Class文件的字节流中包含的信息符合当前
		虚拟机的要求
		验证类型：
			1、文件格式验证(基础验证)
				. 是否以魔数0xCAFEBABE开头
				. 主次版本号是否在当前虚拟机处理范围内
				. 常量池的常量是否由不被支持的常量类型
				. 指向常量池的各种所引致是否有指向不存在的常量或不符合类型的常量
				. CONSTANT_Uft9_info型的常量是否有不符合UTF8编码的数据
				. Class文件中各个部分以及本身是否有被删除的或附加的其他信息
				.....
			2、元数据验证
				. 这个类是否有父类
				. 这个类的父类是否集成了不允许被继承的类
				. 如果这个类不是抽象类，是否实现了其父类或接口中要求实现的所有方法
				. 类中的字段、方法是否与父类产生了矛盾
			3、字节码验证
				. 保证任何时刻操作数栈的数据类型与指令代码序列都能配合工作
				. 保证跳转指令不会跳转到方法体以外的字节指令上
				. 保证方法体中的类型转换是有效的
			4、符号引用验证（非必要）-Xverify:none 关闭验证措施
				该验证发生在将符号引用转化为直接引用的时候
					. 符号引用中通过字符串描述的全限定名是否能找到对应的类
					. 在指定类中是否存在符合方法字段描述符及尖端名称所描述的方法和字段
					. 符号引用中的类、字段和方法的访问行
	3、准备
		为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配
		注意：这时候进行分配的仅包括类变量（被static修饰）
		对于数值类型的变量会赋‘0’值例如
			public static int value = 123;
		此时进行初始化后初始值为0，而不是123	
		
		而对于含有ConstantValue属性，换句话说被‘final’修饰的变量会直接进行初始化
		基本数据类型的零值
			int 		0
			long 		0L
			short		(short)0
			char		'\u0000'
			byte		(byte)0
			boolean		false
			float		0.0f
			double		0.0d
			reference	null
	4、解析		
		将常量池内的符号引用替换为直接引用的过程
			符号引用：使用一组符号来描述所引用的目标，符号可以是任何形式的字面量
			直接引用：直接引用是直接指向目标的指针，相对偏移量、或是一个能直接定位到目标的句柄
			
		类或接口的解析	
			类D  符号引用N 类或接口C
			在D中解析N为C步骤：
			1、如果C不是一个数组类型，那虚拟机会把代表N的全限定名传递给D的类加载器去加载这个类
			在加载过程中，由于无数据验证，字节码验证的需要，可能会触发父类或者实现的接口，一旦这个
			过程出现异常，解析过程就宣告失败
			2、如果C是一个数组类型那么N的描述符就会是类似‘[Ljava.lang.Integer’的形式，那就会按照步骤1
			的形式加载数组元素类型
			3、如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经称为一个有效的类或接口了，
			但在解析完成之前还要进行符号验证，确定C是否具备对D的访问权限，如果没有权限就抛出
			java.lang.IllegalAccessError异常
		字段解析	
			首先会对字段表内的索引进行解析，找到所属类或接口的符号引用用C表示，继续搜素
				1、如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，结束
				2、否则、如果在C中实现了接口，按照继承关系从上往下递归查找每个接口和父接口，如果存在且符合要求
					结束
				3、	如果C不是java.lang.Object按照继承关系搜索父类，找到的话直接返回
				4、上面都没有找到，抛出java.lang.NoSuchFileError异常
				注意：当父类和接口中存在相同的静态变量的时候，引用的时候会抛出the field ... is ambiguous
		类方法解析
			和字段解析一样，也是需要先解析出类方法表中的class_index索引所代表的类或者接口C
				1、类方法和接口符号引用的常量类型定义是分开的，如果在类方法中发现class_index
					索引是一个接口，则抛出java.lang.IncompatibleClassChangeError
				2、在类中查找是否有简单名称和描述符都与目标匹配的方法
				3、父类中查找是否有满足条件的引用
				4、在类实现的接口或者父接口中查找是否有符合条件的方法，找到则说明改类为一个抽象类
					抛出java.lang.AbstractMethodError异常
				5、以上都没有找到，则抛出java.lang.NoSuchMethodError异常
		接口方法解析
				1、与类方法相反，如果在接口方法表中发现class_index的索引，抛出java.lang.IncompatibleClassChangeError
				2、在接口和父类中查找是否有对应的引用，有则直接返回，否则，抛出java.lang.NoSuchMethodError异常
	5、初始化
		1、<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作，和静态语句块合并产生的，编译器收集的顺序是由
			语句在源文件中出现的顺序所决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在之后的变量，静态
			语句块可以赋值但是不能访问
		
		2、<clinit>方法和类的构造函数不同，不需要进行显示地调用父类构造器，虚拟机会保证子类的<clinit>方法
			执行之前，父类的<clinit>方法已经执行完毕，因此在虚拟机的第一个被执行的<clinit>方法肯定是java.lang.Object
		
		3、由于父类的<clinit>方法执行，意味着父类中定义的静态语句块要优先于子类的变量赋值语句操作
		
		4、<clinit>方法对于类或者接口来说并不是必须的，如果一个类中没有静态语句块，也没有变量的赋值语句
			那么编译器可以不为这个类生成<clinit>方法
		
		5、接口中不能使用静态语句块，但是仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>方法，
			但是接口和类不同的是，执行接口的<clinit>方法不需要先执行父接口的<clinit>方法，只有当父接口中定义的
			变量被使用时，父接口才会被初始化，另外，接口的实现类在初始化的时候也一样不会执行接口的<clinit>方法
		6、虚拟机会保证一个类的<clinit>方法在多线程环境中被正确的加锁和同步，如果多个线程同时去初始化一个类，那么
			只会有一个西安测绘给你去执行这个类<clinit>方法，其他线程需要阻塞等待，知道活动线程执行<clinit>方法