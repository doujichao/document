GC搜索算法
----------------------
	1、引用计数法：有引用的时候加1，引用失效的时候减一
		问题：无法解决循环引用的问题
	2、根搜索算法：	通过“GC ROOT”对象向下搜索引用链
		可作为GC ROOT对象包括
			1、虚拟机栈中的引用对象
			2、方法区中的类静态属性引用的对象
			3、方法区中的常量引用对象
			4、本地方法栈中的JNI（本地方法）的引用对象

GC收集算法		
------------------------------
	1、标记-清楚算法
		简介：先对对象进行标记，然后进行清除
		缺点：1、效率问题 标记和清楚效率都不高
			  2、空间问题 会产生大量空间碎片
	2、复制算法
		简介：将内存分为相等的两块，每次收集都将其中存活的对象复制
			到另一块，为存活的对象全部删除
	3、标记-整理算法
		简介：先对对象进行标记，然后将对象向一端进行整理，划分边界，
			对于边界外的对象进行收集
	4、分代收集算法：
		
		
			
引用
----------------------------
	1、强引用	类似于 Object obj=new Object();这类引用
	2、软引用	
		在系统发生内存溢出之前，会将这些对象进行二次回收，
		回收完成之后内存还是不够，则会发生内存溢出异常
	3、弱引用	这些对象只能存在在下次垃圾收集之前
	4、虚引用	主要是在垃圾收集的时候返回一个通知
	
方法区常量池废弃常量，废弃对象收集
-------------------------------------
	废弃常量收集比较简单
	废弃对象收集需要满足条件：
		1、该类所有实例都已经被回收
		2、加载该类的ClassLoader已经被回收
		3、该类没有在任何地方被引用
		
吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）		
		
垃圾收集器
---------------------------------
	分代收集器
		young generation:
			Serial：client模式下的默认收集器
				缺点：在运行的时候会暂停所有线程
				优点：简单、高效
			ParNew：server模式下的默认收集器，可以和CMS配合工作
				Serial收集器的多线程版本
			Parallel Scavenge
				可以设定吞吐量，来影响新生代垃圾回收效率
				可以设定 +UserAdaptiveSizePolicy自动调节各个区域的大小
		Tenured generation:		
			CMS(Concurrent Mark Sweep)
				希望最短系统停顿时间，给用户带来好的体验
				运作过程
					1、初始标记 CMS initial mark
					2、并发标记	CMS concurrent mark
					3、重新标记 CMS remark
					4、并发清除 CMS concurrent sweep
				优点：并发，低停顿
				缺点：1、对CPU资源非常敏感
					  2、无法处理浮动垃圾（浮动垃圾：标记过程中产生的垃圾）
					  3、会产生大量的空间碎片
			Serial Old
				Serial收集器的老年代版本，使用标记-清除算法
			Parallel Old
				Parallel Scavenge收集器的老年代版本
		G1
			基于标记-整理算法
				
Minor GC 
	新生代发生的垃圾收集动作，因为Java对象大多都具备朝生夕死的特性，所有Minor GC
	发生的很频繁
		
Major GC /Full  GC
	发生在老年代的GC，发生Major GC至少会伴随一次Minor GC
	
虚拟机参数 -XX:+PrintGCDetails 会打印垃圾收集的具体信息	
大对象直接进入老年代 -XX:PretenureSizeThreshold
设置对象晋升老年代的年龄阈值：可以通过-XX:MaxTenuringThreshold来设置

空间分配担保
--------------------------
	当对象晋升到老年代的时候，系统会检测老年代的平均大小
	是否大于老年代的剩余空间
		大于：发生一次Full GC
		不大于：判断HadlePromotionFailure是否设置为允许担保失败
			允许，发生一次Minor GC
			不允许：发生一次Full GC
			
可能会占用较多内存的区域
----------------------------------
	1、直接内存缓冲区(Direct Memory),可通过-XX:MaxDirectMemorySize调整大小，内存不足
		时抛出OutOfMemoryError或者OutOfMemoryError:Direct buffer memory
	2、线程堆栈：可通过-Xss调整大小，内存不足时抛出StackOverflowError（纵向无法分配，即
		无法分配新的堆栈）或OutOfMemoryError:Unable to create new native thread（横向
		无法分配，即无法建立新的线程）
	3、Socket缓存区：每个Socket连接都Receive和Send缓存区，分别占大约37kb和25kb的内存
		连接多的话，这块内存占用比较可观，如果无法分配，则可能会抛出IOException：Too many 
		open files 异常
	4、JNI代码：如果代码中使用JNI调用本地库，那本地库使用的内存也不再堆中
	5、虚拟机和GC：虚拟机和GC的代码执行也要消耗一定的内存

一些问题
---------------------------------	
对于分配大堆从而产生网站停顿问题（Full GC频繁触发）	
	高性能硬件上部署程序，主要有两种方式
		1、通过64位jdk来使用大内存
			面临问题：
				1、内存回收导致的长时间停顿
				2、64位jdk的性能测试结果普遍低于32为jdk
				3、需要保证程序足够稳定，因为这种程序产生堆溢出几乎就无法产生堆转储快照
					（因为要产生十几GB乃至更大的dump文件）
				4、相同的程序在64为jdk中消耗的内存一般比32为的jdk大，这是由指针
					膨胀以及数据类型对齐补白等因素导致的
		2、使用若干个32位虚拟机建立逻辑集群来利用硬件资源
	解决方案：建立5个32位jdk的逻辑集群，每个按照2G内存计算，占用10G的内存，采用CMS垃圾收集